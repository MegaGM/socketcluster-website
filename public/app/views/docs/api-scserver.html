<div class="container">
  <div class="row">
    <div class="col-md-3">
      <div ng-include src="'app/shared/nav-docs.html'"></div>
    </div>
    <div class="col-md-9">
      <div class="docs-content">
        <h1>API - SCServer</h1>
        <p>
          This instance is returned from the call to worker.getSCServer(). It represents your
          realtime (WebSocket) server object which you can use to listen for incoming
          realtime socket connections. This object inherits from engine.io's Server
          object so you have access to all the properties and methods of an engine.io
          server but with some additions.
        </p>

        <h3>Inherits from:</h3>
        <p>
          <a href="https://github.com/component/emitter">Emitter</a>
        </p>

        <h3>Properties:</h3>
        <table class="table">
          <tr>
            <td>exchange</td>
            <td>
              A top-level scBroker client which lets you publish and manipulate data within your brokers.
              (See API section on Exchange object for details).
            </td>
          </tr>
          <tr>
            <td>clients</td>
            <td>
              An object which holds all connected clients in the current worker. Keys are socket
              IDs and the values are SCSocket instances.
            </td>
          </tr>
          <tr>
            <td>sourcePort</td>
            <td>The public port on which clients connect to SocketCluster (e.g. 80 for
              HTTP).</td>
          </tr>
          <tr>
            <td>secure</td>
            <td>Whether or not this server uses SSL</td>
          </tr>
          <tr>
            <td>host</td>
            <td>The host name for this server</td>
          </tr>
          <tr>
            <td>ackTimeout</td>
            <td>
              The timeout in milliseconds in which clients have to receive a response to events
              which require acknowledgement. For example, when you provide a callback
              to socket.emit() on the client (it will expect a response from the
              server).
            </td>
          </tr>
        </table>

        <h3>Events:</h3>
        <table class="table">
          <tr>
            <td>'error'</td>
            <td>This gets triggered when fatal error occurs on this worker.</td>
          </tr>
          <tr>
            <td>'notice'</td>
            <td>A notice carries potentially useful information but isn't quite an error.</td>
          </tr>
          <tr>
            <td>'handshake'</td>
            <td>
              Emitted as soon as a new SCSocket object is created on the server - This occurs at
              the beginning of the client handshake, before the 'connection' event.
              You should not try to send events to the socket while it is in this
              state.
            </td>
          </tr>
          <tr>
            <td>'connection'</td>
            <td>
              Emitted whenever a new socket connection is established. The listener to this event
              receives an socket (SCSocket) object as argument which can be used
              to interact with that client.
            </td>
          </tr>
          <tr>
            <td>'badSocketAuthToken'</td>
            <td>
              Emitted when a client tries to authenticate itself with an invalid (or expired) token.
              The first argument passed along with this event is the SCSocket object,
              and the second one is the JWT error object. This error object has an
              additional ecryptedAuthToken property which holds the encrypted token
              which failed the verification step.
            </td>
          </tr>
        </table>

        <h3>Methods:</h3>
        <table class="table">
          <tr>
            <td>setCodecEngine(codecEngine)</td>
            <td>
              <p>
                Lets you set a custom codec engine. This allows you to specify how data gets encoded before being sent over the wire and how it gets decoded once it reaches the other side.
                The codecEngine must be an object which exposes an <code>encode(object)</code> and a <code>decode(encodedData)</code> function. The encode function can return any data type - Comonly a string or a Buffer/ArrayBuffer.
                The decode function needs to return a JavaScript object which adheres to the <a href="https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md">SC protocol</a>.
                The idea of using a custom codec is that it allows you to compress SC packets in any format you like (optimized for any use case) - By decoding these packets back into their original protocol form, SC will be able process them appropriately.
                Note that if you provide a codec engine on the server, you need to provide the same codecEngine as an option when you create the client socket (see 'codecEngine' option <a href="#!/docs/api-socketcluster-client">here</a>).
                The default codec engine used by SC is <a href="https://github.com/SocketCluster/sc-formatter/blob/master/index.js">here</a>.
                If you make an interesting codec engine/module which you feel might be useful for other developers, please feel free to share it with the rest of the SC community.
              </p>
            </td>
          </tr>
          <tr>
            <td>addMiddleware(type, middlewareFn)</td>
            <td>
              <p>
                Lets you add middleware functions which can be used to manage client access control
                to various features of the SCServer. This is useful for monitoring
                realtime data flows and also to block access to restricted channels
                and resources. Note that only actions from clients pass through middleware.
                Server-side calls to scServer.exchange.publish() do not.
              </p>
              <ul>
                <li>
                  <h5>type</h5>
                  <p>
                    A string representing the type of middleware to use, can be:
                  </p>
                  <br />
                  <table class="table">
                    <tr>
                      <td>
                        scServer.MIDDLEWARE_HANDSHAKE - 'handshake' - This middleware function is run before
                        a connection is established during handshake stage.
                      </td>
                    </tr>
                    <tr>
                      <td>
                        scServer.MIDDLEWARE_SUBSCRIBE - 'subscribe' - For all client subscribe() actions.
                      </td>
                    </tr>
                    <tr>
                      <td>
                        scServer.MIDDLEWARE_PUBLISH_IN - 'publishIn' - For all inbound client publish() actions.
                      </td>
                    </tr>
                    <tr>
                      <td>
                        scServer.MIDDLEWARE_PUBLISH_OUT - 'publishOut' - For all outbound client publish()
                        actions. This gets run once for each subscribed client.
                      </td>
                    </tr>
                    <tr>
                      <td>
                        scServer.MIDDLEWARE_EMIT - 'emit' - For all client emit() actions.
                      </td>
                    </tr>
                  </table>
                </li>
                <li>
                  <h5>middlewareFn</h5>
                  <p>
                    A middleware function which can be used to monitor realtime interactions and/or to
                    block unauthorized client actions before they reach the server.
                    Middleware functions are all in the form <code>middlewareFn(req, next)</code> but the req object will have different properties
                    depending on the specified middleware type:
                  </p>
                  <table class="table">
                    <tr>
                      <td>MIDDLEWARE_HANDSHAKE</td>
                      <td>The req object is a Node.js HTTP request object.</td>
                    </tr>
                    <tr>
                      <td>MIDDLEWARE_SUBSCRIBE</td>
                      <td>The req object has the following properties: <code>socket</code> and <code>channel</code>. If the socket had an auth token which has expired, the req object will also have an <code>authTokenExpiredError</code> property which you can optionally pass to the next() method.</td>
                    </tr>
                    <tr>
                      <td>MIDDLEWARE_PUBLISH_IN</td>
                      <td>The req object has the following properties: <code>socket</code>, <code>channel</code> and <code>data</code>. If the socket had an auth token which has expired, the req object will also have an <code>authTokenExpiredError</code> property which you can optionally pass to the next() method.</td>
                    </tr>
                    <tr>
                      <td>MIDDLEWARE_PUBLISH_OUT</td>
                      <td>The req object has the following properties: <code>socket</code>, <code>channel</code> and <code>data</code>. If the socket had an auth token which has expired, the req object will also have an <code>authTokenExpiredError</code> property which you can optionally pass to the next() method.</td>
                    </tr>
                    <tr>
                      <td>MIDDLEWARE_EMIT</td>
                      <td>The req object has the following properties: <code>socket</code>, <code>event</code> and <code>data</code>. If the socket had an auth token which has expired, the req object will also have an <code>authTokenExpiredError</code> property which you can optionally pass to the next() method.</td>
                    </tr>
                  </table>
                </li>
              </ul>
              <p>
                <h5>Example:</h5>
                <p>
                  <a href="#!/docs/middleware-and-authorization">Middleware and authorization</a>
                </p>
            </td>
          </tr>
          <tr>
            <td>removeMiddleware(type, middlewareFn)</td>
            <td>
              <p>
                Lets you remove middleware functions previously added with the addMiddleware() method.
              </p>
            </td>
          </tr>
        </table>
      </div>
    </div>
  </div>
</div>
